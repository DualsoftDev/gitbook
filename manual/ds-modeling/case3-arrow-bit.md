# Case3 : Arrow 인과 연결과 Bit 이중성

#### 1. 개념 소개

DS 시스템에서 실행 흐름을 구성하는 최소 단위는 **Bit**입니다. 이 Bit는 단순한 신호 상태가 아닌, **Arrow를 통한 인과적 연결** 속에서 의미를 가집니다. Bit는 시스템 내에서 특정 결과를 유도하는 동시에, 다음 동작의 원인이 되는 구조로 작동하며, 따라서 Bit는 **원인이자 결과**라는 이중적 특성을 지닙니다.

Bit 자체는 관찰자나 구조 설계자에 의해 Work 또는 Call처럼 분류될 수 있으나, 이는 Bit 고유의 속성이 아닌, 해석의 관점에 따른 것입니다. 즉, Bit는 역할을 수행하는 구조적 객체가 아니라, 흐름에 따라 원인 또는 결과로 해석되는 **관계 중심의 노드**입니다.

> Bit는 이중성을 가지지만, Work/Call은 구조적으로 정의된 단위로서 이중성이 아닌 고정 타입입니다.

***

#### 2. 인과 연결: Arrow를 통한 원인-결과 구조 <a href="#user-content-2-arrow" id="user-content-2-arrow"></a>

```
    A (Bit)
     │
     ▼
    B (Bit)
     │
     ▼
    C (Bit)
```

* **B는 A의 결과이자 C의 원인**입니다.
* Bit는 항상 이전 흐름에 의해 유도되고, 다음 흐름을 유도하는 **중간 인과 노드**입니다.
* 따라서 Bit는 실행 흐름 내에서 **결과이자 원인**인 이중 해석의 지점을 형성합니다.

***

#### 3. 관점에 따른 Bit 해석 <a href="#user-content-3-bit" id="user-content-3-bit"></a>

```
[외부 관찰자 관점]
ApiDef
   │
   ▼
 Bit A  → 외부에 의해 트리거된 경우 "Work"로 보이며 결과로 해석됨

[내부 흐름 관점]
Bit A ──▶ Bit C  → Bit A는 Bit C의 원인으로 해석됨
```

Bit는 외부 ApiDef에 의해 호출될 경우 결과로 해석되며, 이어지는 Bit가 존재한다면 그에 대한 **원인**으로도 해석됩니다. 이처럼 Bit는 **결과로 해석되면서 동시에 다음 동작을 유발하는 원인으로 작용**할 수 있습니다.

#### 4. ApiDef → Work(Bit) → Call(Bit) → ApiCall(Tag) → ApiDef 반복 구조

* DS 시스템에서는 Bit가 **Work처럼 작동하는 단계**와 **Call처럼 작동하는 단계**를 거치며 반복적인 연결 구조를 형성할 수 있습니다.

```
ApiDef → Work(Bit Group) → Call(Bit Group) → ApiCall(Tag) → ApiDef → (반복)
```

* **Work(Bit)**: 시스템 루트에서 선언되는 Bit 그룹으로, 외부 ApiDef에 의해 트리거되고, 관찰 대상이 됨
* **Call(Bit)**: Work 내부에 존재하는 Bit 그룹으로, 외부 시스템을 호출하는 ApiCall을 포함함
* **ApiCall → ApiDef** 연결은 다음 시스템에서 다시 Bit 그룹(Work)으로 변환되어 순환적 구조 형성

이 구조는 **Bit의 흐름을 중심으로 해석되는 동적 연결 구조**로서, 반복되는 시스템 호출과 응답을 유연하게 구성할 수 있습니다.

***

#### 5. 정리 <a href="#user-content-5-1" id="user-content-5-1"></a>

* **Bit는 DS 시스템의 실행 흐름에서 원인이자 결과로 작동하는 이중적 존재**입니다.
* **Arrow는 흐름의 인과를 형성하며, Bit의 의미를 규정짓는 해석 도구**입니다.
* **ApiDef 구조가 존재할 경우, Bit들의 지시/관찰 경계가 형성되어 해당 Bit들이 Work처럼 해석될 수 있으며, 내부 Bit 그룹은 다시 Call처럼 연결될 수 있습니다.**
* 결과적으로 DS 시스템은 Bit 기반 흐름에서 시작하여, **ApiDef → Work → Call → ApiCall → ApiDef** 구조를 반복하는 계층적 인과 연결 체계를 형성합니다
